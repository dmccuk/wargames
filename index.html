<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WOPR // Global Thermonuclear War (Retro UI)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    :root{
      --phosphor: #3cff8f;
      --phosphor-dim: #2bdd6f;
      --bg: #020402;
      --amber: #ffe08a;
      --red: #ff4d4d;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0; background: var(--bg); color: var(--phosphor);
      font-family: 'VT323', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: 0.5px; line-height:1.2;
      overflow:hidden;
    }
    /* CRT feel */
    .crt::before{ /* scanlines */
      content:""; position:fixed; inset:0; pointer-events:none; z-index:9999;
      background: repeating-linear-gradient(
        to bottom,
        rgba(0,0,0,0) 0px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0.12) 3px
      );
      mix-blend-mode: multiply;
    }
    .crt::after{ /* vignette */
      content:""; position:fixed; inset:0; pointer-events:none; z-index:9998;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.25) 75%, rgba(0,0,0,0.6) 100%);
    }

    .glow { text-shadow: 0 0 6px rgba(60,255,143,0.8), 0 0 18px rgba(60,255,143,0.4); }
    .dim  { color: var(--phosphor-dim); opacity:0.9 }

    header{
      padding: 10px 14px; border-bottom: 1px solid rgba(60,255,143,0.25);
      display:flex; gap:16px; align-items:center; justify-content:space-between;
    }
    header .title{ font-size: 28px; }
    header .status{ font-size: 18px; opacity:0.9 }
    header .blink { animation: blink 1s steps(1,end) infinite; }
    @keyframes blink{ 50% { opacity: 0.2 } }

    main{
      display:grid; grid-template-columns: 1.2fr 1.8fr; gap: 8px;
      height: calc(100% - 100px);
      padding: 8px 12px;
    }

    .panel{
      position:relative; border: 1px solid rgba(60,255,143,0.25); border-radius: 10px;
      padding: 12px; background: linear-gradient( to bottom, rgba(60,255,143,0.04), rgba(60,255,143,0.02) 60%, rgba(60,255,143,0.03) );
      box-shadow: inset 0 0 24px rgba(60,255,143,0.08), 0 0 24px rgba(60,255,143,0.06);
    }

    /* Terminal */
    #terminal{
      height: 100%;
      overflow: hidden;
      display:flex; flex-direction:column;
    }
    #term-output{
      flex:1; overflow:auto; padding-right:6px; white-space:pre-wrap;
      font-size: 20px;
    }
    #prompt{ display:flex; gap:8px; align-items:center; }
    #cursor{ width: 10px; height: 18px; background: var(--phosphor); box-shadow: 0 0 8px rgba(60,255,143,0.8); }

    /* Radar / globe panel */
    #globe-wrap{ position:relative; height:100%; }
    #globe { position:absolute; inset:0; }

    .overlay-stats{
      position:absolute; left:12px; bottom:12px; font-size:16px; opacity:0.9;
    }

    footer{
      height: 60px; display:flex; align-items:center; gap:18px; padding: 0 14px; border-top: 1px solid rgba(60,255,143,0.25);
    }
    .badge{ border:1px solid rgba(60,255,143,0.35); padding: 4px 10px; border-radius: 999px; font-size: 18px; }
    .warn{ color: var(--red); text-shadow: 0 0 10px rgba(255,77,77,0.6); border-color: rgba(255,77,77,0.4) }
    .ok{ color: var(--amber); text-shadow: 0 0 10px rgba(255,224,138,0.5) }

    /* Small screens */
    @media (max-width: 900px){
      main{ grid-template-columns: 1fr; height: calc(100% - 120px); }
      header .title{ font-size: 22px }
    }
  </style>
</head>
<body class="crt">
  <header>
    <div class="title glow">W.O.P.R // GLOBAL THERMONUCLEAR WAR</div>
    <div class="status">CONNECTION: <span class="blink">●●●</span> SECURE LINK ESTABLISHED</div>
  </header>

  <main>
    <section class="panel" id="terminal">
      <div id="term-output" aria-live="polite"></div>
      <div id="prompt"><span class="dim">&gt;</span><span id="typing"></span><span id="cursor"></span></div>
      <!-- Invisible, focusable input to reliably capture typing in all embeds/browsers -->
      <input id="ghost-input" autocomplete="off" autocapitalize="off" spellcheck="false" aria-label="Terminal input" style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;" />
    </section>

    <section class="panel" id="globe-wrap">
      <div id="globe"></div>
      <div class="overlay-stats dim">
        MODE: <span class="glow">GLOBAL STRATEGY</span> | TRACKS: <span id="tracks-count">0</span> | DEFCON: <span class="warn glow">3</span>
      </div>
    </section>
  </main>

  <footer>
    <div class="badge">NORAD // CHEYENNE MTN</div>
    <div class="badge ok">SIM: ACTIVE</div>
    <div class="badge">LAST INPUT: <span id="last-input">—</span></div>
  </footer>

  <!-- Three.js for the 3D globe (modern), styled to look retro -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';

    // ---------- Terminal ----------
    const termOut = document.getElementById('term-output');
    const typing = document.getElementById('typing');
    const cursor = document.getElementById('cursor');
    const lastInput = document.getElementById('last-input');

    let inputBuffer = '';
    let history = [];
    let historyIndex = -1;

    const bootLines = [
      'LOGON: JOSHUA',
      'PASSWORD: ••••••••',
      'IDENTIFICATION NOT RECOGNIZED',
      'OVERRIDE: LIST GAMES',
      '',
      'GAMES:',
      '  BLACK JACK',
      '  GIN RUMMY',
      '  FIGHTER COMBAT',
      '  GUERRILLA ENGAGEMENT',
      '  DESERT WARFARE',
      '  AIR-TO-GROUND ACTIONS',
      '  THEATERWIDE TACTICAL WARFARE',
      '  GLOBAL THERMONUCLEAR WAR',
      '',
      'SHALL WE PLAY A GAME? (Y/N)'
    ];

    function printLine(line=""){
      const div = document.createElement('div');
      div.textContent = line; termOut.appendChild(div); termOut.scrollTop = termOut.scrollHeight;
    }

    async function boot(){
      for (const l of bootLines){
        await wait(250);
        printLine(l);
      }
    }

    function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

    function typeToPrompt(str){ typing.textContent = str; }

    function handleCommand(cmd){
      const u = cmd.trim().toUpperCase();
      lastInput.textContent = u || '—';
      printLine('> ' + cmd);
      if (!u){ return; }
      if (u === 'HELP'){
        printLine('COMMANDS: HELP, DEFCON, LIST, RUN <GAME>, CLEAR, STATUS');
      } else if (u === 'LIST'){
        for (const l of bootLines.slice(5, bootLines.length-1)) printLine(l);
      } else if (u.startsWith('RUN ')){
        const game = u.slice(4);
        if (game.includes('THERMONUCLEAR')){ printLine('LAUNCHING: GLOBAL THERMONUCLEAR WAR…'); triggerStrikeDemo(); }
        else { printLine('SIMULATION: ' + game + ' (NOT INSTALLED)'); }
      } else if (u === 'DEFCON'){
        printLine('CURRENT DEFCON: 3');
      } else if (u === 'STATUS'){
        printLine('WOPR STATUS: IDLE; STRATEGY MODEL: ACTIVE; TRACKS: ' + missileTracks.size);
      } else if (u === 'CLEAR'){
        termOut.innerHTML = '';
      } else {
        printLine('UNKNOWN COMMAND. TYPE HELP');
      }
    }

    // Use a hidden input for reliable keyboard capture
    const ghost = document.getElementById('ghost-input');

    function focusGhost(){ ghost.focus(); }
    // Focus on load and whenever the terminal is clicked
    window.addEventListener('load', ()=> setTimeout(focusGhost, 0));
    document.getElementById('terminal').addEventListener('mousedown', focusGhost);
    document.getElementById('terminal').addEventListener('touchstart', focusGhost);

    // Sync regular character input
    ghost.addEventListener('input', ()=>{ inputBuffer = ghost.value; typeToPrompt(inputBuffer); });

    // Handle commands / history keys
    ghost.addEventListener('keydown', (e)=>{
      if (['Alt','Meta','Control'].includes(e.key)) return;
      if (e.key === 'Enter'){
        history.unshift(inputBuffer); historyIndex=-1; handleCommand(inputBuffer); inputBuffer=''; ghost.value=''; typeToPrompt(''); e.preventDefault(); return; }
      if (e.key === 'ArrowUp'){
        if (history.length){ historyIndex = Math.min(historyIndex+1, history.length-1); inputBuffer = history[historyIndex]; ghost.value = inputBuffer; typeToPrompt(inputBuffer);} e.preventDefault(); return; }
      if (e.key === 'ArrowDown'){
        if (history.length){ historyIndex = Math.max(historyIndex-1,-1); inputBuffer = historyIndex>=0? history[historyIndex] : ''; ghost.value=inputBuffer; typeToPrompt(inputBuffer);} e.preventDefault(); return; }
    });

    boot();

    // ---------- 3D Globe ----------
    const wrap = document.getElementById('globe');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 2000);
    camera.position.set(0, 0, 350);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.enablePan = false; controls.minDistance = 200; controls.maxDistance = 600;

    // Glow sprite behind globe
    const glowTex = new THREE.Texture(generateGlowCanvas()); glowTex.needsUpdate = true;
    const glowMat = new THREE.SpriteMaterial({ map: glowTex, color: 0x3cff8f, transparent:true, opacity:0.45, depthWrite:false });
    const glow = new THREE.Sprite(glowMat); glow.scale.set(900,900,1); scene.add(glow);

    // Globe wireframe
    const R = 160;
    const globeGeo = new THREE.SphereGeometry(R, 32, 18);
    const globeMat = new THREE.MeshBasicMaterial({ color: 0x3cff8f, wireframe:true, transparent:true, opacity:0.85 });
    const globe = new THREE.Mesh(globeGeo, globeMat); scene.add(globe);

    // Latitude/Longitude rings for retro grid look
    const rings = new THREE.Group();
    for (let lat=-60; lat<=60; lat+=30){ rings.add(makeLatitudeRing(R+0.1, lat)); }
    for (let lon=0; lon<180; lon+=20){ rings.add(makeLongitudeRing(R+0.1, lon)); }
    scene.add(rings);

    // Stars background (subtle)
    const stars = new THREE.Group();
    for (let i=0;i<200;i++){
      const s = new THREE.Sprite(new THREE.SpriteMaterial({ color: 0x3cff8f, opacity: Math.random()*0.4+0.1 }));
      const d = 1200; s.position.set((Math.random()-0.5)*d, (Math.random()-0.5)*d, (Math.random()-0.5)*d);
      const scale = Math.random()*3+1; s.scale.set(scale,scale,1);
      stars.add(s);
    }
    scene.add(stars);

    // Resize
    function onResize(){
      const rect = wrap.getBoundingClientRect();
      renderer.setSize(rect.width, rect.height, false);
      camera.aspect = rect.width / rect.height; camera.updateProjectionMatrix();
    }
    new ResizeObserver(onResize).observe(wrap);

    // Missile tracks
    const missileTracks = new Set();
    const tracksCount = document.getElementById('tracks-count');

    function addTrack(from, to, duration=6000){
      const curve = arcCurve(from.lat, from.lon, to.lat, to.lon, R*0.8);
      const points = curve.getPoints(200);

      const geo = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.LineBasicMaterial({ color: 0x3cff8f, transparent:true, opacity: 0.9 });
      const line = new THREE.Line(geo, mat);
      line.userData = { t:0, max: points.length, start: performance.now(), dur: duration };
      geo.setDrawRange(0, 0);
      scene.add(line);
      missileTracks.add(line);
      tracksCount.textContent = missileTracks.size;

      // Impact flash at destination
      const impact = makeImpact();
      const end = points[points.length-1];
      impact.position.copy(end);
      impact.userData = { born: performance.now(), life: 900 };
      scene.add(impact);

      return line;
    }

    function triggerStrikeDemo(){
      const cities = [
        { name:'SEATTLE', lat:47.6062, lon:-122.3321 },
        { name:'SAN FRANCISCO', lat:37.7749, lon:-122.4194 },
        { name:'NEW YORK', lat:40.7128, lon:-74.0060 },
        { name:'LONDON', lat:51.5074, lon:-0.1278 },
        { name:'PARIS', lat:48.8566, lon:2.3522 },
        { name:'MOSCOW', lat:55.7558, lon:37.6173 },
        { name:'BEIJING', lat:39.9042, lon:116.4074 },
        { name:'TOKYO', lat:35.6762, lon:139.6503 }
      ];
      // Randomly pick several launch/target pairs
      for (let i=0;i<6;i++){
        const a = cities[Math.floor(Math.random()*cities.length)];
        const b = cities[Math.floor(Math.random()*cities.length)];
        if (a === b) continue;
        addTrack(a, b, 6000 + Math.random()*4000);
      }
    }

    // Utilities
    function latLonToVec3(lat, lon, radius){
      const phi = (90 - lat) * (Math.PI/180);
      const theta = (lon + 180) * (Math.PI/180);
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const z =  radius * Math.sin(phi) * Math.sin(theta);
      const y =  radius * Math.cos(phi);
      return new THREE.Vector3(x,y,z);
    }

    function arcCurve(lat1, lon1, lat2, lon2, height){
      const start = latLonToVec3(lat1, lon1, R);
      const end   = latLonToVec3(lat2, lon2, R);
      const mid = start.clone().add(end).multiplyScalar(0.5);
      const midLen = mid.length();
      mid.normalize();
      mid.multiplyScalar(midLen + height);
      return new THREE.QuadraticBezierCurve3(start, mid, end);
    }

    function makeLatitudeRing(radius, lat){
      const pts = [];
      for (let lon=-180; lon<=180; lon+=2){ pts.push(latLonToVec3(lat, lon, radius)); }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineDashedMaterial({ color: 0x3cff8f, dashSize: 3, gapSize: 2 });
      const line = new THREE.Line(geo, mat); line.computeLineDistances();
      return line;
    }

    function makeLongitudeRing(radius, lon){
      const pts = [];
      for (let lat=-90; lat<=90; lat+=2){ pts.push(latLonToVec3(lat, lon, radius)); }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineDashedMaterial({ color: 0x3cff8f, dashSize: 3, gapSize: 2, transparent:true, opacity:0.8 });
      const line = new THREE.Line(geo, mat); line.computeLineDistances();
      return line;
    }

    function makeImpact(){
      const tex = new THREE.Texture(generateImpactCanvas()); tex.needsUpdate = true;
      const mat = new THREE.SpriteMaterial({ map: tex, color: 0x3cff8f, transparent:true, blending: THREE.AdditiveBlending, opacity:0.8, depthWrite:false });
      const s = new THREE.Sprite(mat); s.scale.set(20,20,1); return s;
    }

    function generateGlowCanvas(){
      const c = document.createElement('canvas'); c.width = c.height = 256; const g = c.getContext('2d');
      const grd = g.createRadialGradient(128,128,10,128,128,128);
      grd.addColorStop(0,'rgba(60,255,143,0.55)');
      grd.addColorStop(1,'rgba(60,255,143,0)');
      g.fillStyle = grd; g.fillRect(0,0,256,256); return c;
    }
    function generateImpactCanvas(){
      const c = document.createElement('canvas'); c.width = c.height = 128; const g = c.getContext('2d');
      g.clearRect(0,0,128,128);
      const grd = g.createRadialGradient(64,64,2,64,64,64);
      grd.addColorStop(0,'rgba(60,255,143,0.9)');
      grd.addColorStop(0.5,'rgba(60,255,143,0.35)');
      grd.addColorStop(1,'rgba(60,255,143,0)');
      g.fillStyle = grd; g.beginPath(); g.arc(64,64,64,0,Math.PI*2); g.fill();
      return c;
    }

    // Animation loop
    function animate(now){
      requestAnimationFrame(animate);
      controls.update();
      globe.rotation.y += 0.0003; rings.rotation.y += 0.0003;

      // reveal missile tracks progressively
      const t = now;
      for (const line of missileTracks){
        const geo = line.geometry; const user = line.userData; const elapsed = t - user.start; const frac = Math.min(1, elapsed / user.dur);
        const segs = Math.floor(user.max * frac);
        geo.setDrawRange(0, segs);
        if (frac >= 1){ // fade out
          line.material.opacity *= 0.985;
          if (line.material.opacity < 0.05){ scene.remove(line); missileTracks.delete(line); tracksCount.textContent = missileTracks.size; }
        }
      }

      // Update impacts (pulse + fade)
      scene.traverse(obj=>{
        if (obj.type === 'Sprite' && obj.userData && obj.userData.life){
          const age = t - obj.userData.born; const f = Math.max(0, 1 - age/obj.userData.life);
          obj.scale.setScalar(20 + (1-f)*40); obj.material.opacity = f*0.9;
          if (age > obj.userData.life) scene.remove(obj);
        }
      });

      renderer.render(scene, camera);
    }
    animate();

    // Kick a periodic demo strike
    setInterval(()=>{ triggerStrikeDemo(); }, 9000);

  </script>

  <script>
    // Accessibility: ensure high-contrast focus ring on key nav
    let hadKeyboardEvent = false;
    const mod = e=>{
      if (e.type === 'keydown') hadKeyboardEvent = true;
      else if (e.type === 'mousedown' || e.type === 'touchstart') hadKeyboardEvent = false;
      document.body.classList.toggle('kbd-nav', hadKeyboardEvent);
    };
    window.addEventListener('keydown', mod, true);
    window.addEventListener('mousedown', mod, true);
    window.addEventListener('touchstart', mod, true);
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WOPR // Global Thermonuclear War (Retro UI)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    :root{
      --phosphor: #3cff8f;
      --phosphor-dim: #2bdd6f;
      --bg: #020402;
      --amber: #ffe08a;
      --red: #ff4d4d;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0; background: var(--bg); color: var(--phosphor);
      font-family: 'VT323', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: 0.5px; line-height:1.2;
      overflow:hidden;
    }
    /* CRT feel */
    .crt::before{ /* scanlines */
      content:""; position:fixed; inset:0; pointer-events:none; z-index:9999;
      background: repeating-linear-gradient(
        to bottom,
        rgba(0,0,0,0) 0px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0.12) 3px
      );
      mix-blend-mode: multiply;
    }
    .crt::after{ /* vignette */
      content:""; position:fixed; inset:0; pointer-events:none; z-index:9998;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.25) 75%, rgba(0,0,0,0.6) 100%);
    }

    .glow { text-shadow: 0 0 6px rgba(60,255,143,0.8), 0 0 18px rgba(60,255,143,0.4); }
    .dim  { color: var(--phosphor-dim); opacity:0.9 }

    header{
      padding: 10px 14px; border-bottom: 1px solid rgba(60,255,143,0.25);
      display:flex; gap:16px; align-items:center; justify-content:space-between;
    }
    header .title{ font-size: 28px; }
    header .status{ font-size: 18px; opacity:0.9 }
    header .blink { animation: blink 1s steps(1,end) infinite; }
    @keyframes blink{ 50% { opacity: 0.2 } }

    main{
      display:grid; grid-template-columns: 1.2fr 1.8fr; gap: 8px;
      height: calc(100% - 100px);
      padding: 8px 12px;
    }

    .panel{
      position:relative; border: 1px solid rgba(60,255,143,0.25); border-radius: 10px;
      padding: 12px; background: linear-gradient( to bottom, rgba(60,255,143,0.04), rgba(60,255,143,0.02) 60%, rgba(60,255,143,0.03) );
      box-shadow: inset 0 0 24px rgba(60,255,143,0.08), 0 0 24px rgba(60,255,143,0.06);
    }

    /* Terminal */
    #terminal{
      height: 100%;
      overflow: hidden;
      display:flex; flex-direction:column;
    }
    #term-output{
      flex:1; overflow:auto; padding-right:6px; white-space:pre-wrap;
      font-size: 20px;
    }
    #prompt{ display:flex; gap:8px; align-items:center; }
    #cursor{ width: 10px; height: 18px; background: var(--phosphor); box-shadow: 0 0 8px rgba(60,255,143,0.8); }

    /* Radar / globe panel */
    #globe-wrap{ position:relative; height:100%; }
    #globe { position:absolute; inset:0; }

    .overlay-stats{
      position:absolute; left:12px; bottom:12px; font-size:16px; opacity:0.9;
    }

    footer{
      height: 60px; display:flex; align-items:center; gap:18px; padding: 0 14px; border-top: 1px solid rgba(60,255,143,0.25);
    }
    .badge{ border:1px solid rgba(60,255,143,0.35); padding: 4px 10px; border-radius: 999px; font-size: 18px; }
    .warn{ color: var(--red); text-shadow: 0 0 10px rgba(255,77,77,0.6); border-color: rgba(255,77,77,0.4) }
    .ok{ color: var(--amber); text-shadow: 0 0 10px rgba(255,224,138,0.5) }

    /* Small screens */
    @media (max-width: 900px){
      main{ grid-template-columns: 1fr; height: calc(100% - 120px); }
      header .title{ font-size: 22px }
    }
    /* Remove default focus ring and use glow */
    .panel:focus, #terminal:focus { outline: none; box-shadow: 0 0 0 2px rgba(60,255,143,0.35), inset 0 0 24px rgba(60,255,143,0.08); }
  </style>
</head>
<body class="crt">
  <header>
    <div class="title glow">W.O.P.R // GLOBAL THERMONUCLEAR WAR</div>
    <div class="status">CONNECTION: <span class="blink">●●●</span> SECURE LINK ESTABLISHED</div>
  </header>

  <main>
    <section class="panel" id="terminal" tabindex="0" aria-label="Terminal (click to focus)">
      <div id="term-output" aria-live="polite"></div>
      <div id="prompt"><span class="dim">&gt;</span><span id="typing"></span><span id="cursor"></span></div>
      <!-- Invisible, focusable input to reliably capture typing in all embeds/browsers -->
      <input id="ghost-input" autocomplete="off" autocapitalize="off" spellcheck="false" aria-label="Terminal input" style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;" />
    </section>

    <section class="panel" id="globe-wrap">
      <div id="globe"></div>
      <div class="overlay-stats dim">
        MODE: <span class="glow">GLOBAL STRATEGY</span> | TRACKS: <span id="tracks-count">0</span> | DEFCON: <span class="warn glow">3</span>
      </div>
    </section>
  </main>

  <footer>
    <div class="badge">NORAD // CHEYENNE MTN</div>
    <div class="badge ok">SIM: ACTIVE</div>
    <div class="badge">LAST INPUT: <span id="last-input">—</span></div>
  </footer>

  <!-- Three.js for the 3D globe (modern), styled to look retro -->
  <script type="module">
    // Fail-safe logger to show errors in the terminal
    function showFatal(err){
      try{
        const term = document.getElementById('term-output');
        if (term){ const d = document.createElement('div'); d.style.color='#ff4d4d'; d.textContent = '[ERROR] ' + (err && err.message ? err.message : err); term.appendChild(d); }
      }catch(_){}
    }

    try{
      // ---------- Terminal (independent of globe engine) ----------
      const termOut = document.getElementById('term-output');
      const typing = document.getElementById('typing');
      const lastInput = document.getElementById('last-input');
      const cursor = document.getElementById('cursor');

      let inputBuffer = '';
      let history = [];
      let historyIndex = -1;
      let terminalActive = false;

      const bootLines = [
        'LOGON: JOSHUA',
        'PASSWORD: ••••••••',
        'IDENTIFICATION NOT RECOGNIZED',
        'OVERRIDE: LIST GAMES',
        '',
        'GAMES:',
        '  BLACK JACK',
        '  GIN RUMMY',
        '  FIGHTER COMBAT',
        '  GUERRILLA ENGAGEMENT',
        '  DESERT WARFARE',
        '  AIR-TO-GROUND ACTIONS',
        '  THEATERWIDE TACTICAL WARFARE',
        '  GLOBAL THERMONUCLEAR WAR',
        '',
        'SHALL WE PLAY A GAME? (Y/N)'
      ];

      function printLine(line=''){ const div = document.createElement('div'); div.textContent=line; termOut.appendChild(div); termOut.scrollTop = termOut.scrollHeight; }
      function typeToPrompt(str){ typing.textContent = str; }
      function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }

      async function boot(){ for (const l of bootLines){ await wait(200); printLine(l); } }

      function handleCommand(cmd){
        const u = cmd.trim(); const U = u.toUpperCase();
        lastInput.textContent = u || '—';
        printLine('> ' + u);
        if (!U) return;
        if (U === 'HELP'){
          printLine('COMMANDS: HELP, DEFCON, LIST, RUN <GAME>, CLEAR, STATUS');
        } else if (U === 'LIST'){
          for (const l of bootLines.slice(5, bootLines.length-1)) printLine(l);
        } else if (U.startsWith('RUN ')){
          const game = U.slice(4);
          if (game.includes('THERMONUCLEAR')){ printLine('LAUNCHING: GLOBAL THERMONUCLEAR WAR…'); triggerStrikeDemo(); }
          else { printLine('SIMULATION: ' + game + ' (NOT INSTALLED)'); }
        } else if (U === 'DEFCON'){
          printLine('CURRENT DEFCON: 3');
        } else if (U === 'STATUS'){
          printLine('WOPR STATUS: IDLE; STRATEGY MODEL: ACTIVE;');
        } else if (U === 'CLEAR'){
          termOut.innerHTML = '';
        } else {
          printLine('UNKNOWN COMMAND. TYPE HELP');
        }
      }

      const termEl = document.getElementById('terminal');
      const ghost = document.getElementById('ghost-input');

      function focusTerminal(){ terminalActive = true; try{ ghost.focus({preventScroll:true}); }catch{ ghost.focus(); } }
      window.addEventListener('load', ()=>{ setTimeout(()=>{ focusTerminal(); boot(); }, 0); });
      termEl.addEventListener('mousedown', focusTerminal);
      termEl.addEventListener('touchstart', focusTerminal);
      termEl.addEventListener('focus', focusTerminal);

      ghost.addEventListener('input', ()=>{ inputBuffer = ghost.value; typeToPrompt(inputBuffer); });
      ghost.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){ history.unshift(inputBuffer); historyIndex=-1; handleCommand(inputBuffer); inputBuffer=''; ghost.value=''; typeToPrompt(''); e.preventDefault(); }
        if (e.key === 'ArrowUp'){ if (history.length){ historyIndex = Math.min(historyIndex+1, history.length-1); inputBuffer = history[historyIndex]; ghost.value=inputBuffer; typeToPrompt(inputBuffer);} e.preventDefault(); }
        if (e.key === 'ArrowDown'){ if (history.length){ historyIndex = Math.max(historyIndex-1,-1); inputBuffer = historyIndex>=0? history[historyIndex] : ''; ghost.value=inputBuffer; typeToPrompt(inputBuffer);} e.preventDefault(); }
      });

      document.addEventListener('keydown', (e)=>{
        const tag = document.activeElement?.tagName || '';
        if (!terminalActive || ['INPUT','TEXTAREA'].includes(tag)) return;
        if (e.key === 'Enter'){ history.unshift(inputBuffer); historyIndex=-1; handleCommand(inputBuffer); inputBuffer=''; ghost.value=''; typeToPrompt(''); e.preventDefault(); return; }
        if (e.key === 'Backspace'){ inputBuffer = inputBuffer.slice(0,-1); ghost.value=inputBuffer; typeToPrompt(inputBuffer); e.preventDefault(); return; }
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown'){
          if (history.length){ if (e.key === 'ArrowUp') historyIndex = Math.min(historyIndex+1, history.length-1); else historyIndex = Math.max(historyIndex-1,-1); inputBuffer = historyIndex>=0? history[historyIndex] : ''; ghost.value=inputBuffer; typeToPrompt(inputBuffer);} e.preventDefault(); return; }
        if (e.key.length === 1 && !e.metaKey && !e.ctrlKey){ inputBuffer += e.key; ghost.value=inputBuffer; typeToPrompt(inputBuffer); e.preventDefault(); }
      });

      // ---------- Globe selection (Three.js or Canvas fallback) ----------
      const wrap = document.getElementById('globe');
      const tracksCount = document.getElementById('tracks-count');
      let addTrack = ()=>{};
      function triggerStrikeDemo(){
        const cities = [
          { name:'SEATTLE', lat:47.6062, lon:-122.3321 },
          { name:'SAN FRANCISCO', lat:37.7749, lon:-122.4194 },
          { name:'NEW YORK', lat:40.7128, lon:-74.0060 },
          { name:'LONDON', lat:51.5074, lon:-0.1278 },
          { name:'PARIS', lat:48.8566, lon:2.3522 },
          { name:'MOSCOW', lat:55.7558, lon:37.6173 },
          { name:'BEIJING', lat:39.9042, lon:116.4074 },
          { name:'TOKYO', lat:35.6762, lon:139.6503 }
        ];
        for (let i=0;i<6;i++){
          const a = cities[Math.floor(Math.random()*cities.length)];
          const b = cities[Math.floor(Math.random()*cities.length)];
          if (a===b) continue; addTrack(a,b, 6000+Math.random()*4000);
        }
      }

      // Try webgl -> fallback to canvas
      (async function(){
        try{
          const THREE = await import('https://unpkg.com/three@0.159.0/build/three.module.js');
          const { OrbitControls } = await import('https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js');
          initThree(THREE, OrbitControls);
        }catch(err){
          console.warn('Three.js unavailable, using Canvas fallback', err);
          initCanvasFallback();
        }
      })();

      function initThree(THREE, OrbitControls){
        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true }); wrap.innerHTML=''; wrap.appendChild(renderer.domElement);
        const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 2000); camera.position.set(0,0,350);
        const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping=true; controls.enablePan=false; controls.minDistance=200; controls.maxDistance=600;
        const R = 160;
        const glowTex = new THREE.Texture(generateGlowCanvas()); glowTex.needsUpdate=true; const glowMat = new THREE.SpriteMaterial({ map: glowTex, color: 0x3cff8f, transparent:true, opacity:0.45, depthWrite:false }); const glow = new THREE.Sprite(glowMat); glow.scale.set(900,900,1); scene.add(glow);
        const globeGeo = new THREE.SphereGeometry(R, 32, 18); const globeMat = new THREE.MeshBasicMaterial({ color: 0x3cff8f, wireframe:true, transparent:true, opacity:0.85 }); const globe = new THREE.Mesh(globeGeo, globeMat); scene.add(globe);
        const rings = new THREE.Group(); for (let lat=-60; lat<=60; lat+=30){ rings.add(makeLatitudeRingThree(THREE,R+0.1, lat)); } for (let lon=0; lon<180; lon+=20){ rings.add(makeLongitudeRingThree(THREE,R+0.1, lon)); } scene.add(rings);
        const stars = new THREE.Group(); for (let i=0;i<200;i++){ const s = new THREE.Sprite(new THREE.SpriteMaterial({ color:0x3cff8f, opacity: Math.random()*0.4+0.1 })); const d=1200; s.position.set((Math.random()-0.5)*d,(Math.random()-0.5)*d,(Math.random()-0.5)*d); const sc=Math.random()*3+1; s.scale.set(sc,sc,1); stars.add(s);} scene.add(stars);
        function onResize(){ const rect = wrap.getBoundingClientRect(); renderer.setSize(rect.width, rect.height, false); camera.aspect=rect.width/rect.height; camera.updateProjectionMatrix(); }
        new ResizeObserver(onResize).observe(wrap); window.addEventListener('resize', onResize); setTimeout(onResize,0);
        const missileTracks = new Set();
        addTrack = function(from,to,duration=6000){ const curve = arcCurveThree(THREE, from.lat, from.lon, to.lat, to.lon, R*0.8); const points = curve.getPoints(200); const geo = new THREE.BufferGeometry().setFromPoints(points); const mat = new THREE.LineBasicMaterial({ color: 0x3cff8f, transparent:true, opacity:0.9 }); const line = new THREE.Line(geo, mat); line.userData = { max: points.length, start: performance.now(), dur: duration }; geo.setDrawRange(0,0); scene.add(line); missileTracks.add(line); tracksCount.textContent = missileTracks.size; const impact = makeImpactThree(THREE); const end = points[points.length-1]; impact.position.copy(end); impact.userData = { born: performance.now(), life: 900 }; scene.add(impact); return line; };
        function animate(now){ requestAnimationFrame(animate); controls.update(); globe.rotation.y += 0.0003; rings.rotation.y += 0.0003; for (const line of missileTracks){ const geo=line.geometry; const u=line.userData; const elapsed= now - u.start; const frac=Math.min(1, elapsed/u.dur); const segs=Math.floor(u.max*frac); geo.setDrawRange(0,segs); if (frac>=1){ line.material.opacity *= 0.985; if (line.material.opacity<0.05){ scene.remove(line); missileTracks.delete(line); tracksCount.textContent = missileTracks.size; } } } scene.traverse(obj=>{ if (obj.type==='Sprite' && obj.userData && obj.userData.life){ const age=now-obj.userData.born; const f=Math.max(0,1-age/obj.userData.life); obj.scale.setScalar(20+(1-f)*40); obj.material.opacity=f*0.9; if (age>obj.userData.life) scene.remove(obj); } }); renderer.render(scene,camera); } animate(); setInterval(()=>triggerStrikeDemo(), 9000);
        function latLonToVec3(lat, lon, radius){ const phi=(90-lat)*(Math.PI/180); const theta=(lon+180)*(Math.PI/180); const x = -radius*Math.sin(phi)*Math.cos(theta); const z = radius*Math.sin(phi)*Math.sin(theta); const y = radius*Math.cos(phi); return new THREE.Vector3(x,y,z); }
        function arcCurveThree(THREE, lat1,lon1,lat2,lon2,height){ const R=160; const start=latLonToVec3(lat1,lon1,R); const end=latLonToVec3(lat2,lon2,R); const mid=start.clone().add(end).multiplyScalar(0.5); const midLen=mid.length(); mid.normalize(); mid.multiplyScalar(midLen+height); return new THREE.QuadraticBezierCurve3(start,mid,end); }
        function makeLatitudeRingThree(THREE, radius, lat){ const pts=[]; for (let lon=-180; lon<=180; lon+=2){ pts.push(latLonToVec3(lat,lon,radius)); } const geo=new THREE.BufferGeometry().setFromPoints(pts); const mat=new THREE.LineDashedMaterial({ color:0x3cff8f, dashSize:3, gapSize:2 }); const line=new THREE.Line(geo,mat); line.computeLineDistances(); return line; }
        function makeLongitudeRingThree(THREE, radius, lon){ const pts=[]; for (let lat=-90; lat<=90; lat+=2){ pts.push(latLonToVec3(lat,lon,radius)); } const geo=new THREE.BufferGeometry().setFromPoints(pts); const mat=new THREE.LineDashedMaterial({ color:0x3cff8f, dashSize:3, gapSize:2, transparent:true, opacity:0.8 }); const line=new THREE.Line(geo,mat); line.computeLineDistances(); return line; }
        function makeImpactThree(THREE){ const tex=new THREE.Texture(generateImpactCanvas()); tex.needsUpdate=true; const mat=new THREE.SpriteMaterial({ map:tex, color:0x3cff8f, transparent:true, blending: THREE.AdditiveBlending, opacity:0.8, depthWrite:false }); const s=new THREE.Sprite(mat); s.scale.set(20,20,1); return s; }
      }

      function initCanvasFallback(){
        const canvas=document.createElement('canvas'); const ctx=canvas.getContext('2d'); wrap.innerHTML=''; wrap.appendChild(canvas);
        function onResize(){ const r=wrap.getBoundingClientRect(); canvas.width=Math.max(1, r.width); canvas.height=Math.max(1, r.height); }
        new ResizeObserver(onResize).observe(wrap); window.addEventListener('resize', onResize); setTimeout(onResize,0);
        const R=160; let rot=0; const tracks=[];
        addTrack=function(from,to,duration=6000){ const start=Date.now(); tracks.push({from,to,start,duration,done:false}); tracksCount.textContent=tracks.filter(t=>!t.done).length; };
        function proj(x,y,z){ // simple perspective (front hemisphere only)
        const scale = 300/(300+z); // z>0 ensured by caller
        return {x: canvas.width/2 + x*scale, y: canvas.height/2 + y*scale};
      }; }
        function rotY(x,z,a){ const ca=Math.cos(a), sa=Math.sin(a); return {x: x*ca - z*sa, z: x*sa + z*ca}; }
        function latLonToXYZ(lat,lon,rad){ const phi=(90-lat)*(Math.PI/180); const theta=(lon+180)*(Math.PI/180); const x = -rad*Math.sin(phi)*Math.cos(theta); const z = rad*Math.sin(phi)*Math.sin(theta); const y = rad*Math.cos(phi); return {x,y,z}; }
        function drawGraticule(){
          ctx.globalAlpha=0.9; ctx.lineWidth=1; ctx.lineCap='round';
          ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--phosphor') || '#3cff8f';
          function strokeFront(points){
            ctx.beginPath();
            let penDown=false; let prevS=null;
            for (let i=0;i<points.length;i++){
              const p=points[i];
              const r=rotY(p.x,p.z,rot); const zc=r.z;
              if (zc<=0){ penDown=false; prevS=null; continue; }
              const s=proj(r.x,p.y,zc);
              if (!penDown){ ctx.moveTo(s.x,s.y); penDown=true; prevS=s; continue; }
              const dx=s.x - prevS.x, dy=s.y - prevS.y;
              if (dx*dx + dy*dy > 2500){ // big jump across seam -> start new subpath
                ctx.moveTo(s.x,s.y);
              } else {
                ctx.lineTo(s.x,s.y);
              }
              prevS=s;
            }
            ctx.stroke();
          }
          for (let lat=-60; lat<=60; lat+=30){ const pts=[]; for (let lon=-180; lon<=180; lon+=2){ pts.push(latLonToXYZ(lat,lon,R)); } strokeFront(pts); }
          for (let lon=0; lon<180; lon+=20){ const pts=[]; for (let lat=-90; lat<=90; lat+=2){ pts.push(latLonToXYZ(lat,lon,R)); } strokeFront(pts); }
        } const s=proj(r.x,p.y,zc); if(!penDown){ ctx.moveTo(s.x,s.y); penDown=true; } else { ctx.lineTo(s.x,s.y); } } ctx.stroke(); }
          for (let lat=-60; lat<=60; lat+=30){ const pts=[]; for (let lon=-180; lon<=180; lon+=2){ pts.push(latLonToXYZ(lat,lon,R)); } strokeFront(pts); }
          for (let lon=0; lon<180; lon+=20){ const pts=[]; for (let lat=-90; lat<=90; lat+=2){ pts.push(latLonToXYZ(lat,lon,R)); } strokeFront(pts); }
        }
        function drawTracks(){
          const now=Date.now(); ctx.lineWidth=2; ctx.globalAlpha=0.9; ctx.lineCap='round'; ctx.strokeStyle='#3cff8f';
          tracks.forEach(t=>{
            const p1=latLonToXYZ(t.from.lat,t.from.lon,R);
            const p2=latLonToXYZ(t.to.lat,t.to.lon,R);
            const mid={x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 + R*0.5, z:(p1.z+p2.z)/2};
            const steps=160; const elapsed=Math.min(1,(now-t.start)/t.duration); const endIdx=Math.floor(steps*elapsed);
            ctx.beginPath(); let penDown=false; let prevS=null;
            for (let i=0;i<=endIdx;i++){
              const a=i/steps;
              const xa=(1-a)*(1-a)*p1.x + 2*(1-a)*a*mid.x + a*a*p2.x;
              const ya=(1-a)*(1-a)*p1.y + 2*(1-a)*a*mid.y + a*a*p2.y;
              const za=(1-a)*(1-a)*p1.z + 2*(1-a)*a*mid.z + a*a*p2.z;
              const r=rotY(xa,za,rot); const zc=r.z; if (zc<=0){ penDown=false; prevS=null; continue; }
              const s=proj(r.x,ya,zc);
              if (!penDown){ ctx.moveTo(s.x,s.y); penDown=true; prevS=s; continue; }
              const dx=s.x - prevS.x, dy=s.y - prevS.y;
              if (dx*dx + dy*dy > 2500){ ctx.moveTo(s.x,s.y); }
              else { ctx.lineTo(s.x,s.y); }
              prevS=s;
            }
            ctx.stroke();
            if (elapsed>=1) t.done=true;
          });
          tracksCount.textContent = tracks.filter(t=>!t.done).length;
        }; const steps=160; const elapsed=Math.min(1,(now-t.start)/t.duration); const endIdx=Math.floor(steps*elapsed); let penDown=false; ctx.beginPath(); for (let i=0;i<=endIdx;i++){ const a=i/steps; const xa=(1-a)*(1-a)*p1.x + 2*(1-a)*a*mid.x + a*a*p2.x; const ya=(1-a)*(1-a)*p1.y + 2*(1-a)*a*mid.y + a*a*p2.y; const za=(1-a)*(1-a)*p1.z + 2*(1-a)*a*mid.z + a*a*p2.z; const r=rotY(xa,za,rot); const zc=r.z; if (zc<=0){ penDown=false; continue; } const s=proj(r.x,ya,zc); if(!penDown){ ctx.moveTo(s.x,s.y); penDown=true; } else ctx.lineTo(s.x,s.y); } ctx.stroke(); if (elapsed>=1) t.done=true; }); tracksCount.textContent = tracks.filter(t=>!t.done).length; }
        function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); rot += 0.003; drawGraticule(); drawTracks(); requestAnimationFrame(draw); }
        draw(); setInterval(()=> triggerStrikeDemo(), 9000);
      }

      function generateGlowCanvas(){ const c=document.createElement('canvas'); c.width=c.height=256; const g=c.getContext('2d'); const grd=g.createRadialGradient(128,128,10,128,128,128); grd.addColorStop(0,'rgba(60,255,143,0.55)'); grd.addColorStop(1,'rgba(60,255,143,0)'); g.fillStyle=grd; g.fillRect(0,0,256,256); return c; }
      function generateImpactCanvas(){ const c=document.createElement('canvas'); c.width=c.height=128; const g=c.getContext('2d'); g.clearRect(0,0,128,128); const grd=g.createRadialGradient(64,64,2,64,64,64); grd.addColorStop(0,'rgba(60,255,143,0.9)'); grd.addColorStop(0.5,'rgba(60,255,143,0.35)'); grd.addColorStop(1,'rgba(60,255,143,0)'); g.fillStyle=grd; g.beginPath(); g.arc(64,64,64,0,Math.PI*2); g.fill(); return c; }
    } catch(err){ showFatal(err); }
  </script>

  <script>
    // Accessibility: ensure high-contrast focus ring on key nav
    let hadKeyboardEvent = false;
    const mod = e=>{
      if (e.type === 'keydown') hadKeyboardEvent = true;
      else if (e.type === 'mousedown' || e.type === 'touchstart') hadKeyboardEvent = false;
      document.body.classList.toggle('kbd-nav', hadKeyboardEvent);
    };
    window.addEventListener('keydown', mod, true);
    window.addEventListener('mousedown', mod, true);
    window.addEventListener('touchstart', mod, true);
  </script>
</body>
</html>

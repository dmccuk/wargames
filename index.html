<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retro Wireframe Globe (80s style)</title>
<style>
  :root{ --phosphor:#3cff8f; --bg:#050807; }
  html,body{height:100%; margin:0}
  body{ background: var(--bg); display:grid; place-items:center; color:var(--phosphor); }
  canvas{ width:min(90vmin,900px); height:min(90vmin,900px); display:block; }
  /* CRT vibe (optional) */
  body::before{content:"";position:fixed;inset:0;pointer-events:none;background:repeating-linear-gradient( to bottom, rgba(0,0,0,0) 0px, rgba(0,0,0,0) 2px, rgba(0,0,0,0.12) 3px );mix-blend-mode:multiply}
</style>
</head>
<body>
<canvas id="globe"></canvas>
<script>
(function(){
  const canvas = document.getElementById('globe');
  const ctx = canvas.getContext('2d');
  const color = getComputedStyle(document.documentElement).getPropertyValue('--phosphor') || '#3cff8f';

  function resize(){
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const side = Math.min(window.innerWidth, window.innerHeight) * 0.9;
    canvas.width = Math.floor(side * dpr);
    canvas.height = Math.floor(side * dpr);
    canvas.style.width = Math.floor(side) + 'px';
    canvas.style.height = Math.floor(side) + 'px';
  }
  resize(); window.addEventListener('resize', resize);

  const R = 220; // logical radius in px (before perspective)
  let rot = 0;   // rotation around Y

  // perspective projection (camera at (0,0, -d) looking to +z)
  const d = 600;
  function proj(x,y,z){ const s = d/(d+z); return {x: cx + x*s, y: cy + y*s}; }
  function rotY(p, a){ const ca=Math.cos(a), sa=Math.sin(a); return {x: p.x*ca - p.z*sa, y: p.y, z: p.x*sa + p.z*ca}; }
  function latLonToXYZ(lat, lon, r){ const phi=(90-lat)*(Math.PI/180); const theta=(lon+180)*(Math.PI/180); return { x: -r*Math.sin(phi)*Math.cos(theta), y: r*Math.cos(phi), z: r*Math.sin(phi)*Math.sin(theta) }; }

  // Draw a param line on sphere: either latitude or longitude
  function drawLine(generator){
    const steps = 360; // smoothness
    // Build points with rotation applied
    const pts = [];
    for (let i=0;i<=steps;i++){
      const t = -180 + i*(360/steps);
      const p = generator(t);
      const pr = rotY(p, rot);
      pts.push(pr);
    }
    // First render back hemisphere (ghosted, dashed), then front solid
    function stroke(whereBack){
      ctx.beginPath();
      let pen=false; let prev=null;
      for (let i=0;i<pts.length;i++){
        const P = pts[i];
        const back = (P.z < 0);
        if (back !== whereBack){ pen=false; continue; }
        const s = proj(P.x, P.y, P.z);
        if (!pen){ ctx.moveTo(s.x, s.y); pen=true; prev=s; continue; }
        // avoid seam spikes (skip long jumps)
        const dx=s.x-prev.x, dy=s.y-prev.y; if (dx*dx+dy*dy> (canvas.width*canvas.height)/200){ ctx.moveTo(s.x,s.y); prev=s; continue; }
        ctx.lineTo(s.x, s.y); prev=s;
      }
      ctx.stroke();
    }
    // back (ghost)
    ctx.save(); ctx.strokeStyle=color; ctx.globalAlpha=0.25; ctx.setLineDash([6,5]); ctx.lineWidth=1; ctx.lineCap='round'; stroke(true); ctx.restore();
    // front (solid)
    ctx.save(); ctx.strokeStyle=color; ctx.globalAlpha=0.95; ctx.setLineDash([]); ctx.lineWidth=2; ctx.lineCap='round'; stroke(false); ctx.restore();
  }

  function drawGraticule(){
    // Latitudes every 15°, from -75..75 (avoid poles crowding)
    for (let lat=-75; lat<=75; lat+=15){
      drawLine((lon)=> latLonToXYZ(lat, lon, R));
    }
    // Longitudes every 15°
    for (let lon=-180; lon<180; lon+=15){
      drawLine((lat)=> latLonToXYZ(lat, lon, R));
    }
  }

  function frame(){
    const w = canvas.width, h = canvas.height; ctx.clearRect(0,0,w,h);
    cx = w/2; cy = h/2; // center

    // Outer glow
    const g = ctx.createRadialGradient(cx,cy, R*0.2, cx,cy, R*1.1);
    g.addColorStop(0, 'rgba(60,255,143,0.15)'); g.addColorStop(1,'rgba(60,255,143,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,R*1.1,0,Math.PI*2); ctx.fill();

    drawGraticule();

    rot += 0.003; // slow spin
    requestAnimationFrame(frame);
  }

  let cx=0, cy=0; // canvas center (set in frame)
  frame();
})();
</script>
</body>
</html>
